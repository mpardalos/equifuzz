{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module GenSystemC.GenTransformations (seedExpr, randomTransformationFor, isFinalExpr, randomFinalTransformation) where

import Control.Monad (guard, join)
import Control.Monad.Random.Strict (MonadRandom, getRandomR, uniform, weighted)
import Data.Maybe (catMaybes, isJust)
import Data.Set qualified as Set
import GenSystemC.Transformations
  ( BuildOut,
    Transformation (..),
  )
import SystemC qualified as SC

randomTransformationFor :: MonadRandom m => SC.Expr BuildOut -> m Transformation
randomTransformationFor e =
  join . weighted . map (,1) . catMaybes $
    [ Just castWithDeclaration,
      guard (isJust $ SC.supportsRange e.annotation)
        >> range <$> SC.specifiedWidth e.annotation,
      arithmetic <$> arithmeticResultType,
      guard canBeBool
        >> Just useAsCondition,
      guard (isJust $ SC.supportsBitref e.annotation)
        >> bitSelect <$> SC.specifiedWidth e.annotation
    ]
  where
    castWithDeclaration = CastWithDeclaration <$> castTargetType e.annotation

    range width = do
      hi <- getRandomR (0, width - 1)
      lo <- getRandomR (0, hi)
      return (Range hi lo)

    arithmeticResultType
      | [t] <-
          Set.toList $
            Set.intersection
              (Set.fromList [SC.CInt, SC.CUInt, SC.CDouble])
              (SC.implicitCastTargetsOf e.annotation) =
          Just t
      | otherwise = Nothing

    arithmetic resultType = do
      op <- uniform [SC.Plus, SC.Minus, SC.Multiply]
      constant <- someConstant resultType
      return (Arithmetic op constant)

    canBeBool :: Bool
    canBeBool = SC.CBool `elem` SC.implicitCastTargetsOf e.annotation

    useAsCondition =
      UseAsCondition
        <$> someConstant SC.CInt
        <*> someConstant SC.CInt

    bitSelect width = BitSelect <$> getRandomR (0, width - 1)

    someConstant :: MonadRandom m => SC.SCType -> m (SC.Expr BuildOut)
    someConstant t = SC.Constant t <$> getRandomR (-1024, 1024)

seedExpr :: MonadRandom m => m (SC.Expr BuildOut)
seedExpr = do
  value <- getRandomR (-128, 128)
  return (SC.Constant SC.CInt value)

randomFinalTransformation :: MonadRandom m => SC.Expr BuildOut -> m Transformation
randomFinalTransformation e = CastWithDeclaration <$> finalCastType e.annotation

isFinalExpr :: SC.Expr BuildOut -> Bool
isFinalExpr e = case e.annotation of
  SC.SCInt {} -> True
  SC.SCFixed {} -> True
  SC.SCUInt {} -> True
  SC.SCUFixed {} -> True
  SC.CInt -> False
  SC.CUInt -> False
  SC.CDouble -> False
  SC.CBool -> False
  SC.SCFxnumSubref -> False
  SC.SCIntSubref -> False
  SC.SCUIntSubref -> False
  SC.SCIntBitref -> False
  SC.SCUIntBitref -> False


finalCastType :: MonadRandom m => SC.SCType -> m SC.SCType
finalCastType =
  -- It just so happens that all the types generated by `castTargetType` are
  -- valid final types. This alias exists to show that we specifically want
  -- this.
  castTargetType

-- Generate a type that the input type can be cast to
castTargetType :: MonadRandom m => SC.SCType -> m SC.SCType
castTargetType = \case
  -- FIXME: fixed-to-uint is broken for the version of vcf I am currently
  -- testing. This workaround should be an option at the top level.
  SC.SCFixed {} -> join $ uniform [someFixed, someUFixed]
  SC.SCUFixed {} -> join $ uniform [someFixed, someUFixed]
  SC.SCFxnumSubref {} -> join $ uniform [someInt, someUInt]
  _ -> join $ uniform [someInt, someUInt, someFixed, someUFixed]
  where
    someInt = SC.SCInt <$> someWidth
    someUInt = SC.SCUInt <$> someWidth
    someFixed = do
      w <- someWidth
      i <- getRandomR (0, w)
      return (SC.SCFixed w i)
    someUFixed = do
      w <- someWidth
      i <- getRandomR (0, w)
      return (SC.SCUFixed w i)

    someWidth :: MonadRandom m => m Int
    someWidth = getRandomR (1, 64)
